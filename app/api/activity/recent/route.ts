import { NextResponse } from "next/server"
import { v4 as uuidv4 } from "uuid"

// Mock data - in a real application, this would come from a database
const mockActivities = [
  {
    id: uuidv4(),
    type: "company_creation",
    description: "New company 'Innovate Corp' added.",
    timestamp: new Date(Date.now() - 2 * 60 * 1000).toISOString(), // 2 minutes ago
    status: "completed",
    link: "/companies/innovate-corp-id", // Example link
  },
  {
    id: uuidv4(),
    type: "message_sent",
    description: "Email sent to 'contact@example.com' for campaign 'Q1 Outreach'.",
    timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(), // 5 minutes ago
    status: "sent",
    link: "/comms/campaigns/q1-outreach/log/message-id",
  },
  {
    id: uuidv4(),
    type: "scraper_run",
    description: "Scraper 'Lead Finder X' completed a run.",
    timestamp: new Date(Date.now() - 10 * 60 * 1000).toISOString(), // 10 minutes ago
    status: "completed",
    link: "/scrapers/lead-finder-x-id/runs/run-id",
  },
  {
    id: uuidv4(),
    type: "funnel_lead_added",
    description: "New lead 'John Doe' added to funnel 'Sales Pipeline'.",
    timestamp: new Date(Date.now() - 15 * 60 * 1000).toISOString(), // 15 minutes ago
    status: "active",
    link: "/funnels/sales-pipeline/leads/john-doe-id",
  },
  {
    id: uuidv4(),
    type: "scraper_error",
    description: "Scraper 'Data Miner Pro' encountered an error.",
    timestamp: new Date(Date.now() - 30 * 60 * 1000).toISOString(), // 30 minutes ago
    status: "failed",
    link: "/scrapers/data-miner-pro-id/runs/run-id-error",
  },
  {
    id: uuidv4(),
    type: "company_update",
    description: "Company 'Tech Solutions Ltd.' details updated.",
    timestamp: new Date(Date.now() - 60 * 60 * 1000).toISOString(), // 1 hour ago
    status: "completed",
    link: "/companies/tech-solutions-ltd-id",
  },
]

export async function GET(request: Request) {
  try {
    // In a real application, you would fetch and aggregate data from various sources (databases, services).
    // For this example, we're returning a sorted slice of mock data.
    // Sorting by timestamp descending to get the most recent activities first.
    const recentActivities = mockActivities
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, 7) // Return up to 7 recent activities

    return NextResponse.json(recentActivities, { status: 200 })
  } catch (error) {
    console.error("Recent Activity API error:", error)
    return NextResponse.json(
      {
        success: false,
        message: "Failed to fetch recent activity",
        errors: [{ code: "fetch_error", message: error instanceof Error ? error.message : "Unknown error" }],
      },
      { status: 500 },
    )
  }
}

// A simple function to simulate adding a new activity (for testing purposes if needed)
// In a real app, activities would be generated by other services/events.
export function addMockActivity(activity: Omit<typeof mockActivities[0], "id" | "timestamp">) {
  const newActivity = {
    ...activity,
    id: uuidv4(),
    timestamp: new Date().toISOString(),
  }
  mockActivities.unshift(newActivity) // Add to the beginning
  if (mockActivities.length > 20) { // Keep the mock list from growing too large
    mockActivities.pop()
  }
  return newActivity
}
